use mockall::mock;
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use alloy_consensus::{Header as ConsensusHeader, TxEip1559, TxEnvelope};
use alloy_primitives::{Address, FixedBytes, U256};
use alloy_provider::utils::Eip1559Estimation;
use alloy_rpc_types::{Header, TransactionRequest};
use alloy_signer::Signature;

use block_building::{
    preconf::{config::Config, Preconfer},
    taiko::taiko_client::{ITaikoClient, TaikoClientResult},
    taiko::taiko_l1_client::{ITaikoL1Client, TaikoL1ClientResult},
    time_provider::ITimeProvider,
};

mock! {
    #[derive(Debug)]
    pub TaikoClient{}

    impl ITaikoClient for TaikoClient {
        async fn get_mempool_txs(
            &self,
            beneficiary: Address,
            base_fee: u64,
        ) -> TaikoClientResult<Vec<TxEnvelope>>;

        async fn get_base_fee(
            &self,
            parent_gas_used: u64,
            timestamp: u64,
        ) -> TaikoClientResult<u128>;

        async fn get_nonce(&self, address: &str) -> TaikoClientResult<u64>;

        async fn estimate_gas(&self, tx: TransactionRequest) -> TaikoClientResult<u64>;

        async fn estimate_eip1559_fees(&self) -> TaikoClientResult<Eip1559Estimation>;

        fn get_signed_anchor_tx(
            &self,
            anchor_block_id: u64,
            anchor_state_root: FixedBytes<32>,
            parent_gas_used: u32,
            nonce: u64,
            max_fee_per_gas: u128,
        ) -> TaikoClientResult<TxEnvelope>;

        async fn publish_preconfirmed_transactions(
            &self,
            fee_recipient: Address,
            base_fee: u64,
            timestamp: u64,
            parent_header: &Header,
            txs: Vec<TxEnvelope>,
        ) -> TaikoClientResult<Header>;
    }
}

mock! {
    #[derive(Debug)]
    pub TaikoL1Client{}

    impl ITaikoL1Client for TaikoL1Client {
        async fn get_nonce(&self, address: &str) -> TaikoL1ClientResult<u64>;

        async fn get_header(&self, id: u64) -> TaikoL1ClientResult<ConsensusHeader>;

        async fn estimate_gas(&self, tx: TransactionRequest) -> TaikoL1ClientResult<u64>;

        async fn estimate_eip1559_fees(&self) -> TaikoL1ClientResult<Eip1559Estimation>;
    }
}

mock! {
    #[derive(Debug)]
    pub TimeProvider{}

    impl ITimeProvider for TimeProvider {
        fn now(&self) -> SystemTime;
        fn timestamp_in_s(&self) -> u64;
    }
}

fn get_rpc_header(inner: ConsensusHeader) -> Header {
    Header {
        hash: FixedBytes::<32>::default(),
        inner,
        total_difficulty: None,
        size: None,
    }
}

fn get_header(number: u64, timestamp: u64) -> ConsensusHeader {
    ConsensusHeader {
        number,
        timestamp,
        ..Default::default()
    }
}

const DUMMY_NONCE: u64 = 10;
const DUMMY_BASE_FEE: u128 = 100;
const DUMMY_BLOCK_NUMBER: u64 = 1234;
const DUMMY_TIMESTAMP: u64 = 987654321;
const DUMMY_GAS: u64 = 30000;
const DUMMY_MAX_FEE_PER_GAS: u128 = 50000;
const DUMMY_MAX_PRIORITY_FEE_PER_GAS: u128 = 70000;

#[tokio::test]
async fn test_build_blocks_adds_anchor_transaction() {
    let config = Config::default();
    let last_block_timestamp = 1_000_000u64;
    let next_block_desired_timestamp = last_block_timestamp + config.l2_block_time.as_secs();

    let mut l1_client = MockTaikoL1Client::new();
    l1_client
        .expect_get_nonce()
        .return_once(|_| Ok(DUMMY_NONCE));
    l1_client
        .expect_get_header()
        .return_once(|_| Ok(ConsensusHeader::default()));
    l1_client.expect_estimate_eip1559_fees().return_once(|| {
        Ok(Eip1559Estimation {
            max_fee_per_gas: DUMMY_MAX_FEE_PER_GAS,
            max_priority_fee_per_gas: DUMMY_MAX_PRIORITY_FEE_PER_GAS,
        })
    });

    let mut taiko = MockTaikoClient::new();
    taiko.expect_get_nonce().return_once(|_| Ok(DUMMY_NONCE));
    taiko
        .expect_get_base_fee()
        .return_once(|_, _| Ok(DUMMY_BASE_FEE));
    taiko
        .expect_get_signed_anchor_tx()
        .return_once(|_, _, _, _, _| {
            Ok(TxEnvelope::new_unhashed(
                TxEip1559::default().into(),
                Signature::new(U256::ONE, U256::default(), false),
            ))
        });
    taiko.expect_estimate_gas().return_once(|_| Ok(DUMMY_GAS));
    taiko
        .expect_publish_preconfirmed_transactions()
        .withf(|_, _, _, _, txs| txs.len() == 2 && txs[0].signature().r() == U256::ONE)
        .return_once(|_, _, _, _, _| {
            Ok(get_rpc_header(get_header(
                DUMMY_BLOCK_NUMBER,
                DUMMY_TIMESTAMP,
            )))
        });
    taiko.expect_get_mempool_txs().return_once(|_, _| {
        Ok(vec![TxEnvelope::new_unhashed(
            TxEip1559::default().into(),
            Signature::new(U256::default(), U256::default(), false),
        )])
    });

    let mut time_provider = MockTimeProvider::new();
    time_provider.expect_now().return_const(
        UNIX_EPOCH
            .checked_add(Duration::from_secs(next_block_desired_timestamp))
            .unwrap(),
    );
    time_provider
        .expect_timestamp_in_s()
        .return_const(next_block_desired_timestamp);

    let preconfer_address = Address::random();

    let preconfer = Preconfer::new(config, l1_client, taiko, preconfer_address, time_provider);
    *preconfer.shared_last_l1_block_number().lock().await = DUMMY_BLOCK_NUMBER;

    let parent_header = get_rpc_header(get_header(DUMMY_BLOCK_NUMBER, last_block_timestamp));
    assert!(preconfer.build_block(parent_header).await.is_ok());
}
